// This file is auto-generated by @hey-api/openapi-ts

import { type InfiniteData, infiniteQueryOptions, queryOptions, type UseMutationOptions } from '@tanstack/react-query';

import { client } from '../client.gen';
import { findDispatchPostById, findDispatchPosts, findJourneyById, findJourneysByEvent, findJourneysByIds, findJourneysByPlayableDeparture, findJourneysByRailcar, findMapPolylineByJourney, findPointById, findPointByName, findPointByPosition, findPointBySimRailPointId, findPointsById, findRailcarByApiName, findRailcarById, findRailcarsByIds, findServerByCode, findServerById, findUserDetails, findVehicleCompositionByJourneyId, listActiveJourneys, listBoardArrivals, listBoardDepartures, listPoints, listServers, type Options } from '../sdk.gen';
import type { FindDispatchPostByIdData, FindDispatchPostByIdError, FindDispatchPostByIdResponse, FindDispatchPostsData, FindDispatchPostsError, FindDispatchPostsResponse, FindJourneyByIdData, FindJourneyByIdError, FindJourneyByIdResponse, FindJourneysByEventData, FindJourneysByEventError, FindJourneysByEventResponse, FindJourneysByIdsData, FindJourneysByIdsError, FindJourneysByIdsResponse, FindJourneysByPlayableDepartureData, FindJourneysByPlayableDepartureError, FindJourneysByPlayableDepartureResponse, FindJourneysByRailcarData, FindJourneysByRailcarError, FindJourneysByRailcarResponse, FindMapPolylineByJourneyData, FindMapPolylineByJourneyError, FindMapPolylineByJourneyResponse, FindPointByIdData, FindPointByIdError, FindPointByIdResponse, FindPointByNameData, FindPointByNameError, FindPointByNameResponse, FindPointByPositionData, FindPointByPositionError, FindPointByPositionResponse, FindPointBySimRailPointIdData, FindPointBySimRailPointIdError, FindPointBySimRailPointIdResponse, FindPointsByIdData, FindPointsByIdError, FindPointsByIdResponse, FindRailcarByApiNameData, FindRailcarByApiNameError, FindRailcarByApiNameResponse, FindRailcarByIdData, FindRailcarByIdError, FindRailcarByIdResponse, FindRailcarsByIdsData, FindRailcarsByIdsError, FindRailcarsByIdsResponse, FindServerByCodeData, FindServerByCodeError, FindServerByCodeResponse, FindServerByIdData, FindServerByIdError, FindServerByIdResponse, FindUserDetailsData, FindUserDetailsError, FindUserDetailsResponse, FindVehicleCompositionByJourneyIdData, FindVehicleCompositionByJourneyIdError, FindVehicleCompositionByJourneyIdResponse, ListActiveJourneysData, ListActiveJourneysError, ListActiveJourneysResponse, ListBoardArrivalsData, ListBoardArrivalsError, ListBoardArrivalsResponse, ListBoardDeparturesData, ListBoardDeparturesError, ListBoardDeparturesResponse, ListPointsData, ListPointsError, ListPointsResponse, ListServersData, ListServersError, ListServersResponse } from '../types.gen';

/**
 * Get a batch of detailed user information (up to 250)
 *
 * Get a batch of detailed user information (up to 250) in a single request. If an id is provided which can't be
 * resolved to a user info, the id is skipped and there will be no reference to the id in the response array.
 *
 */
export const findUserDetailsMutation = (options?: Partial<Options<FindUserDetailsData>>): UseMutationOptions<FindUserDetailsResponse, FindUserDetailsError, Options<FindUserDetailsData>> => {
    const mutationOptions: UseMutationOptions<FindUserDetailsResponse, FindUserDetailsError, Options<FindUserDetailsData>> = {
        mutationFn: async (fnOptions) => await findUserDetails({
            ...options,
            ...fnOptions,
            throwOnError: true
        })
    };
    return mutationOptions;
};

/**
 * Get a batch of railcars (up to 250) by their id
 */
export const findRailcarsByIdsMutation = (options?: Partial<Options<FindRailcarsByIdsData>>): UseMutationOptions<FindRailcarsByIdsResponse, FindRailcarsByIdsError, Options<FindRailcarsByIdsData>> => {
    const mutationOptions: UseMutationOptions<FindRailcarsByIdsResponse, FindRailcarsByIdsError, Options<FindRailcarsByIdsData>> = {
        mutationFn: async (fnOptions) => await findRailcarsByIds({
            ...options,
            ...fnOptions,
            throwOnError: true
        })
    };
    return mutationOptions;
};

/**
 * Get a batch of points (up to 250) by their id
 *
 * Get a batch of points (up to 250) in a single request. If an id is provided which doesn't have a point associated,
 * the id is skipped and there will be no reference to the id in the response array
 *
 */
export const findPointsByIdMutation = (options?: Partial<Options<FindPointsByIdData>>): UseMutationOptions<FindPointsByIdResponse, FindPointsByIdError, Options<FindPointsByIdData>> => {
    const mutationOptions: UseMutationOptions<FindPointsByIdResponse, FindPointsByIdError, Options<FindPointsByIdData>> = {
        mutationFn: async (fnOptions) => await findPointsById({
            ...options,
            ...fnOptions,
            throwOnError: true
        })
    };
    return mutationOptions;
};

/**
 * Get a batch of journeys (up to 250) by their id
 */
export const findJourneysByIdsMutation = (options?: Partial<Options<FindJourneysByIdsData>>): UseMutationOptions<FindJourneysByIdsResponse, FindJourneysByIdsError, Options<FindJourneysByIdsData>> => {
    const mutationOptions: UseMutationOptions<FindJourneysByIdsResponse, FindJourneysByIdsError, Options<FindJourneysByIdsData>> = {
        mutationFn: async (fnOptions) => await findJourneysByIds({
            ...options,
            ...fnOptions,
            throwOnError: true
        })
    };
    return mutationOptions;
};

export type QueryKey<TOptions extends Options> = [
    Pick<TOptions, 'baseUrl' | 'body' | 'headers' | 'path' | 'query'> & {
        _id: string;
        _infinite?: boolean;
        tags?: ReadonlyArray<string>;
    }
];

const createQueryKey = <TOptions extends Options>(id: string, options?: TOptions, infinite?: boolean, tags?: ReadonlyArray<string>): [
    QueryKey<TOptions>[0]
] => {
    const params: QueryKey<TOptions>[0] = { _id: id, baseUrl: options?.baseUrl || (options?.client ?? client).getConfig().baseUrl } as QueryKey<TOptions>[0];
    if (infinite) {
        params._infinite = infinite;
    }
    if (tags) {
        params.tags = tags;
    }
    if (options?.body) {
        params.body = options.body;
    }
    if (options?.headers) {
        params.headers = options.headers;
    }
    if (options?.path) {
        params.path = options.path;
    }
    if (options?.query) {
        params.query = options.query;
    }
    return [params];
};

export const findVehicleCompositionByJourneyIdQueryKey = (options: Options<FindVehicleCompositionByJourneyIdData>) => createQueryKey('findVehicleCompositionByJourneyId', options);

/**
 * Get the vehicle composition of a journey
 */
export const findVehicleCompositionByJourneyIdOptions = (options: Options<FindVehicleCompositionByJourneyIdData>) => queryOptions<FindVehicleCompositionByJourneyIdResponse, FindVehicleCompositionByJourneyIdError, FindVehicleCompositionByJourneyIdResponse, ReturnType<typeof findVehicleCompositionByJourneyIdQueryKey>>({
    queryFn: async ({ queryKey, signal }) => await findVehicleCompositionByJourneyId({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true
    }),
    queryKey: findVehicleCompositionByJourneyIdQueryKey(options)
});

export const findServerByIdQueryKey = (options: Options<FindServerByIdData>) => createQueryKey('findServerById', options);

/**
 * Get detail data about a single server by ID
 */
export const findServerByIdOptions = (options: Options<FindServerByIdData>) => queryOptions<FindServerByIdResponse, FindServerByIdError, FindServerByIdResponse, ReturnType<typeof findServerByIdQueryKey>>({
    queryFn: async ({ queryKey, signal }) => await findServerById({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true
    }),
    queryKey: findServerByIdQueryKey(options)
});

export const findServerByCodeQueryKey = (options: Options<FindServerByCodeData>) => createQueryKey('findServerByCode', options);

/**
 * Get detail data about a single server by code
 */
export const findServerByCodeOptions = (options: Options<FindServerByCodeData>) => queryOptions<FindServerByCodeResponse, FindServerByCodeError, FindServerByCodeResponse, ReturnType<typeof findServerByCodeQueryKey>>({
    queryFn: async ({ queryKey, signal }) => await findServerByCode({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true
    }),
    queryKey: findServerByCodeQueryKey(options)
});

export const listServersQueryKey = (options?: Options<ListServersData>) => createQueryKey('listServers', options);

/**
 * List all registered servers
 */
export const listServersOptions = (options?: Options<ListServersData>) => queryOptions<ListServersResponse, ListServersError, ListServersResponse, ReturnType<typeof listServersQueryKey>>({
    queryFn: async ({ queryKey, signal }) => await listServers({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true
    }),
    queryKey: listServersQueryKey(options)
});

export const findRailcarByApiNameQueryKey = (options: Options<FindRailcarByApiNameData>) => createQueryKey('findRailcarByApiName', options);

/**
 * Finds a single railcar using the given SimRail api id
 */
export const findRailcarByApiNameOptions = (options: Options<FindRailcarByApiNameData>) => queryOptions<FindRailcarByApiNameResponse, FindRailcarByApiNameError, FindRailcarByApiNameResponse, ReturnType<typeof findRailcarByApiNameQueryKey>>({
    queryFn: async ({ queryKey, signal }) => await findRailcarByApiName({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true
    }),
    queryKey: findRailcarByApiNameQueryKey(options)
});

export const findRailcarByIdQueryKey = (options: Options<FindRailcarByIdData>) => createQueryKey('findRailcarById', options);

/**
 * Finds a single railcar using the given id
 */
export const findRailcarByIdOptions = (options: Options<FindRailcarByIdData>) => queryOptions<FindRailcarByIdResponse, FindRailcarByIdError, FindRailcarByIdResponse, ReturnType<typeof findRailcarByIdQueryKey>>({
    queryFn: async ({ queryKey, signal }) => await findRailcarById({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true
    }),
    queryKey: findRailcarByIdQueryKey(options)
});

export const findPointByPositionQueryKey = (options: Options<FindPointByPositionData>) => createQueryKey('findPointByPosition', options);

/**
 * Finds points that are located in a specified around around a given geo position
 *
 * Finds points that are in the given radius around the given geo position. Results are sorted by their distance to
 * the given geo point, ASC (nearest point first).
 *
 */
export const findPointByPositionOptions = (options: Options<FindPointByPositionData>) => queryOptions<FindPointByPositionResponse, FindPointByPositionError, FindPointByPositionResponse, ReturnType<typeof findPointByPositionQueryKey>>({
    queryFn: async ({ queryKey, signal }) => await findPointByPosition({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true
    }),
    queryKey: findPointByPositionQueryKey(options)
});

export const findPointBySimRailPointIdQueryKey = (options: Options<FindPointBySimRailPointIdData>) => createQueryKey('findPointBySimRailPointId', options);

/**
 * Get a point by its SimRail point id
 *
 * Gets a point by its SimRail point id". Note that the resulting points are grouped by their operational unit, for
 * example '2528' (Małogoszcz) and '5460' (Małogoszcz PZS R35) will both return 'Małogoszcz'. Also note that some
 * points might not return any result if they are too close together and one point represents them enough
 * (for example the case for 'Zawiercie' and 'Zawiercie GT')
 *
 */
export const findPointBySimRailPointIdOptions = (options: Options<FindPointBySimRailPointIdData>) => queryOptions<FindPointBySimRailPointIdResponse, FindPointBySimRailPointIdError, FindPointBySimRailPointIdResponse, ReturnType<typeof findPointBySimRailPointIdQueryKey>>({
    queryFn: async ({ queryKey, signal }) => await findPointBySimRailPointId({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true
    }),
    queryKey: findPointBySimRailPointIdQueryKey(options)
});

export const findPointByNameQueryKey = (options: Options<FindPointByNameData>) => createQueryKey('findPointByName', options);

/**
 * Finds points whose name are matching the given search query
 *
 * Fuzzy searches points by the given name search query. For example the search input 'Lazy' will return 'Łazy',
 * 'Łazy Łc', 'Łazy Ła' etc. Wildcard search patterns are not supported by this endpoint. Results are sorted by match
 * with the given search query, DESC (best match first).
 *
 */
export const findPointByNameOptions = (options: Options<FindPointByNameData>) => queryOptions<FindPointByNameResponse, FindPointByNameError, FindPointByNameResponse, ReturnType<typeof findPointByNameQueryKey>>({
    queryFn: async ({ queryKey, signal }) => await findPointByName({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true
    }),
    queryKey: findPointByNameQueryKey(options)
});

export const findPointByIdQueryKey = (options: Options<FindPointByIdData>) => createQueryKey('findPointById', options);

/**
 * Get the full data of a point by its id
 */
export const findPointByIdOptions = (options: Options<FindPointByIdData>) => queryOptions<FindPointByIdResponse, FindPointByIdError, FindPointByIdResponse, ReturnType<typeof findPointByIdQueryKey>>({
    queryFn: async ({ queryKey, signal }) => await findPointById({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true
    }),
    queryKey: findPointByIdQueryKey(options)
});

export const listPointsQueryKey = (options?: Options<ListPointsData>) => createQueryKey('listPoints', options);

/**
 * List all points that are registered
 */
export const listPointsOptions = (options?: Options<ListPointsData>) => queryOptions<ListPointsResponse, ListPointsError, ListPointsResponse, ReturnType<typeof listPointsQueryKey>>({
    queryFn: async ({ queryKey, signal }) => await listPoints({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true
    }),
    queryKey: listPointsQueryKey(options)
});

const createInfiniteParams = <K extends Pick<QueryKey<Options>[0], 'body' | 'headers' | 'path' | 'query'>>(queryKey: QueryKey<Options>, page: K) => {
    const params = { ...queryKey[0] };
    if (page.body) {
        params.body = {
            ...queryKey[0].body as any,
            ...page.body as any
        };
    }
    if (page.headers) {
        params.headers = {
            ...queryKey[0].headers,
            ...page.headers
        };
    }
    if (page.path) {
        params.path = {
            ...queryKey[0].path as any,
            ...page.path as any
        };
    }
    if (page.query) {
        params.query = {
            ...queryKey[0].query as any,
            ...page.query as any
        };
    }
    return params as unknown as typeof page;
};

export const listPointsInfiniteQueryKey = (options?: Options<ListPointsData>): QueryKey<Options<ListPointsData>> => createQueryKey('listPoints', options, true);

/**
 * List all points that are registered
 */
export const listPointsInfiniteOptions = (options?: Options<ListPointsData>) => infiniteQueryOptions<ListPointsResponse, ListPointsError, InfiniteData<ListPointsResponse>, QueryKey<Options<ListPointsData>>, number | Pick<QueryKey<Options<ListPointsData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
// @ts-ignore
{
    queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<QueryKey<Options<ListPointsData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
            query: {
                page: pageParam
            }
        };
        const params = createInfiniteParams(queryKey, page);
        return await listPoints({
            ...options,
            ...params,
            signal,
            throwOnError: true
        });
    },
    queryKey: listPointsInfiniteQueryKey(options)
});

export const findMapPolylineByJourneyQueryKey = (options: Options<FindMapPolylineByJourneyData>) => createQueryKey('findMapPolylineByJourney', options);

/**
 * Get the polyline for a specific journey
 */
export const findMapPolylineByJourneyOptions = (options: Options<FindMapPolylineByJourneyData>) => queryOptions<FindMapPolylineByJourneyResponse, FindMapPolylineByJourneyError, FindMapPolylineByJourneyResponse, ReturnType<typeof findMapPolylineByJourneyQueryKey>>({
    queryFn: async ({ queryKey, signal }) => await findMapPolylineByJourney({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true
    }),
    queryKey: findMapPolylineByJourneyQueryKey(options)
});

export const findJourneysByRailcarQueryKey = (options: Options<FindJourneysByRailcarData>) => createQueryKey('findJourneysByRailcar', options);

/**
 * Finds journeys that are using the given railcars in their vehicle composition
 *
 * Finds journeys that use the given railcars in their vehicle composition on the given date. The results might be
 * incomplete or incorrect for journeys that were not active yet, as the result data will be based on predictions
 * and not the real composition of the journey.
 *
 */
export const findJourneysByRailcarOptions = (options: Options<FindJourneysByRailcarData>) => queryOptions<FindJourneysByRailcarResponse, FindJourneysByRailcarError, FindJourneysByRailcarResponse, ReturnType<typeof findJourneysByRailcarQueryKey>>({
    queryFn: async ({ queryKey, signal }) => await findJourneysByRailcar({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true
    }),
    queryKey: findJourneysByRailcarQueryKey(options)
});

export const findJourneysByRailcarInfiniteQueryKey = (options: Options<FindJourneysByRailcarData>): QueryKey<Options<FindJourneysByRailcarData>> => createQueryKey('findJourneysByRailcar', options, true);

/**
 * Finds journeys that are using the given railcars in their vehicle composition
 *
 * Finds journeys that use the given railcars in their vehicle composition on the given date. The results might be
 * incomplete or incorrect for journeys that were not active yet, as the result data will be based on predictions
 * and not the real composition of the journey.
 *
 */
export const findJourneysByRailcarInfiniteOptions = (options: Options<FindJourneysByRailcarData>) => infiniteQueryOptions<FindJourneysByRailcarResponse, FindJourneysByRailcarError, InfiniteData<FindJourneysByRailcarResponse>, QueryKey<Options<FindJourneysByRailcarData>>, number | Pick<QueryKey<Options<FindJourneysByRailcarData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
// @ts-ignore
{
    queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<QueryKey<Options<FindJourneysByRailcarData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
            query: {
                page: pageParam
            }
        };
        const params = createInfiniteParams(queryKey, page);
        return await findJourneysByRailcar({
            ...options,
            ...params,
            signal,
            throwOnError: true
        });
    },
    queryKey: findJourneysByRailcarInfiniteQueryKey(options)
});

export const findJourneysByPlayableDepartureQueryKey = (options: Options<FindJourneysByPlayableDepartureData>) => createQueryKey('findJourneysByPlayableDeparture', options);

/**
 * Find journeys that become playable in the provided time range
 *
 * Finds journeys that become playable in the provided time range. Optionally additional filter parameters can be
 * provided to narrow down the results. The provided time range must be at least 1 minute and at most 60 minutes
 * long. If the start time is omitted it defaults to the current server time, if the end time is omitted it defaults
 * to the start time plus 15 minutes.
 *
 */
export const findJourneysByPlayableDepartureOptions = (options: Options<FindJourneysByPlayableDepartureData>) => queryOptions<FindJourneysByPlayableDepartureResponse, FindJourneysByPlayableDepartureError, FindJourneysByPlayableDepartureResponse, ReturnType<typeof findJourneysByPlayableDepartureQueryKey>>({
    queryFn: async ({ queryKey, signal }) => await findJourneysByPlayableDeparture({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true
    }),
    queryKey: findJourneysByPlayableDepartureQueryKey(options)
});

export const findJourneysByPlayableDepartureInfiniteQueryKey = (options: Options<FindJourneysByPlayableDepartureData>): QueryKey<Options<FindJourneysByPlayableDepartureData>> => createQueryKey('findJourneysByPlayableDeparture', options, true);

/**
 * Find journeys that become playable in the provided time range
 *
 * Finds journeys that become playable in the provided time range. Optionally additional filter parameters can be
 * provided to narrow down the results. The provided time range must be at least 1 minute and at most 60 minutes
 * long. If the start time is omitted it defaults to the current server time, if the end time is omitted it defaults
 * to the start time plus 15 minutes.
 *
 */
export const findJourneysByPlayableDepartureInfiniteOptions = (options: Options<FindJourneysByPlayableDepartureData>) => infiniteQueryOptions<FindJourneysByPlayableDepartureResponse, FindJourneysByPlayableDepartureError, InfiniteData<FindJourneysByPlayableDepartureResponse>, QueryKey<Options<FindJourneysByPlayableDepartureData>>, number | Pick<QueryKey<Options<FindJourneysByPlayableDepartureData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
// @ts-ignore
{
    queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<QueryKey<Options<FindJourneysByPlayableDepartureData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
            query: {
                page: pageParam
            }
        };
        const params = createInfiniteParams(queryKey, page);
        return await findJourneysByPlayableDeparture({
            ...options,
            ...params,
            signal,
            throwOnError: true
        });
    },
    queryKey: findJourneysByPlayableDepartureInfiniteQueryKey(options)
});

export const findJourneyByIdQueryKey = (options: Options<FindJourneyByIdData>) => createQueryKey('findJourneyById', options);

/**
 * Returns a single journey by the given id
 */
export const findJourneyByIdOptions = (options: Options<FindJourneyByIdData>) => queryOptions<FindJourneyByIdResponse, FindJourneyByIdError, FindJourneyByIdResponse, ReturnType<typeof findJourneyByIdQueryKey>>({
    queryFn: async ({ queryKey, signal }) => await findJourneyById({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true
    }),
    queryKey: findJourneyByIdQueryKey(options)
});

export const findJourneysByEventQueryKey = (options: Options<FindJourneysByEventData>) => createQueryKey('findJourneysByEvent', options);

/**
 * Find journeys based on one journey event matching the given search criteria
 *
 * Find journeys based on one journey event matching the given search criteria, for example:
 * - Searching for journey number '40180' will return 'EIP 40180', 'ROJ 40180' etc.
 * - Searching for 'PWJ 146051' will also return 'ROJ 19369' that starts as 'ROJ' but switches to 'PWJ' along its route
 * - Searching for 'RE1' at '2024-12-06' will also return journeys that start at '2024-12-05' and continue on '2024-12-06'
 * Multiple filter parameter can be provided and are linked in a logical AND chain. At least the journey number or
 * journey line must be provided.
 *
 */
export const findJourneysByEventOptions = (options: Options<FindJourneysByEventData>) => queryOptions<FindJourneysByEventResponse, FindJourneysByEventError, FindJourneysByEventResponse, ReturnType<typeof findJourneysByEventQueryKey>>({
    queryFn: async ({ queryKey, signal }) => await findJourneysByEvent({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true
    }),
    queryKey: findJourneysByEventQueryKey(options)
});

export const findJourneysByEventInfiniteQueryKey = (options: Options<FindJourneysByEventData>): QueryKey<Options<FindJourneysByEventData>> => createQueryKey('findJourneysByEvent', options, true);

/**
 * Find journeys based on one journey event matching the given search criteria
 *
 * Find journeys based on one journey event matching the given search criteria, for example:
 * - Searching for journey number '40180' will return 'EIP 40180', 'ROJ 40180' etc.
 * - Searching for 'PWJ 146051' will also return 'ROJ 19369' that starts as 'ROJ' but switches to 'PWJ' along its route
 * - Searching for 'RE1' at '2024-12-06' will also return journeys that start at '2024-12-05' and continue on '2024-12-06'
 * Multiple filter parameter can be provided and are linked in a logical AND chain. At least the journey number or
 * journey line must be provided.
 *
 */
export const findJourneysByEventInfiniteOptions = (options: Options<FindJourneysByEventData>) => infiniteQueryOptions<FindJourneysByEventResponse, FindJourneysByEventError, InfiniteData<FindJourneysByEventResponse>, QueryKey<Options<FindJourneysByEventData>>, number | Pick<QueryKey<Options<FindJourneysByEventData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
// @ts-ignore
{
    queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<QueryKey<Options<FindJourneysByEventData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
            query: {
                page: pageParam
            }
        };
        const params = createInfiniteParams(queryKey, page);
        return await findJourneysByEvent({
            ...options,
            ...params,
            signal,
            throwOnError: true
        });
    },
    queryKey: findJourneysByEventInfiniteQueryKey(options)
});

export const listActiveJourneysQueryKey = (options: Options<ListActiveJourneysData>) => createQueryKey('listActiveJourneys', options);

/**
 * Get all journeys that are currently active on a server
 *
 * Get descriptive information about all journeys that are currently active on a server. Data returned by this
 * endpoint updates every 15 seconds. This endpoint shouldn't be used to poll journey updates, use the event system
 * SIT-Events instead.
 *
 */
export const listActiveJourneysOptions = (options: Options<ListActiveJourneysData>) => queryOptions<ListActiveJourneysResponse, ListActiveJourneysError, ListActiveJourneysResponse, ReturnType<typeof listActiveJourneysQueryKey>>({
    queryFn: async ({ queryKey, signal }) => await listActiveJourneys({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true
    }),
    queryKey: listActiveJourneysQueryKey(options)
});

export const findDispatchPostsQueryKey = (options?: Options<FindDispatchPostsData>) => createQueryKey('findDispatchPosts', options);

/**
 * Find dispatch posts based on the given filter parameters
 *
 * Finds dispatch posts paginated based on the given filter parameters. If multiple filter parameters are provided,
 * they get chained into a logical AND chain. If no filter parameters are provided, this endpoint acts like a
 * listing endpoint.
 *
 */
export const findDispatchPostsOptions = (options?: Options<FindDispatchPostsData>) => queryOptions<FindDispatchPostsResponse, FindDispatchPostsError, FindDispatchPostsResponse, ReturnType<typeof findDispatchPostsQueryKey>>({
    queryFn: async ({ queryKey, signal }) => await findDispatchPosts({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true
    }),
    queryKey: findDispatchPostsQueryKey(options)
});

export const findDispatchPostsInfiniteQueryKey = (options?: Options<FindDispatchPostsData>): QueryKey<Options<FindDispatchPostsData>> => createQueryKey('findDispatchPosts', options, true);

/**
 * Find dispatch posts based on the given filter parameters
 *
 * Finds dispatch posts paginated based on the given filter parameters. If multiple filter parameters are provided,
 * they get chained into a logical AND chain. If no filter parameters are provided, this endpoint acts like a
 * listing endpoint.
 *
 */
export const findDispatchPostsInfiniteOptions = (options?: Options<FindDispatchPostsData>) => infiniteQueryOptions<FindDispatchPostsResponse, FindDispatchPostsError, InfiniteData<FindDispatchPostsResponse>, QueryKey<Options<FindDispatchPostsData>>, number | Pick<QueryKey<Options<FindDispatchPostsData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
// @ts-ignore
{
    queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<QueryKey<Options<FindDispatchPostsData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
            query: {
                page: pageParam
            }
        };
        const params = createInfiniteParams(queryKey, page);
        return await findDispatchPosts({
            ...options,
            ...params,
            signal,
            throwOnError: true
        });
    },
    queryKey: findDispatchPostsInfiniteQueryKey(options)
});

export const findDispatchPostByIdQueryKey = (options: Options<FindDispatchPostByIdData>) => createQueryKey('findDispatchPostById', options);

/**
 * Get the detail information of a single dispatch post by its id
 */
export const findDispatchPostByIdOptions = (options: Options<FindDispatchPostByIdData>) => queryOptions<FindDispatchPostByIdResponse, FindDispatchPostByIdError, FindDispatchPostByIdResponse, ReturnType<typeof findDispatchPostByIdQueryKey>>({
    queryFn: async ({ queryKey, signal }) => await findDispatchPostById({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true
    }),
    queryKey: findDispatchPostByIdQueryKey(options)
});

export const listBoardDeparturesQueryKey = (options: Options<ListBoardDeparturesData>) => createQueryKey('listBoardDepartures', options);

/**
 * Get all departures within a specified timespan at a specified point
 *
 * Lists all journeys that are departing from the specified point on the specified server within the given time span.
 * By default, a time span of 30 minutes is returned, starting at the current server time, unless otherwise specified.
 * Results are sorted by realtime time information by default. A minimum time span of 5 minutes and a maximum time
 * span of 6 hours can be requested. The start time can be 1 day in the future and 90 days in the past.
 *
 */
export const listBoardDeparturesOptions = (options: Options<ListBoardDeparturesData>) => queryOptions<ListBoardDeparturesResponse, ListBoardDeparturesError, ListBoardDeparturesResponse, ReturnType<typeof listBoardDeparturesQueryKey>>({
    queryFn: async ({ queryKey, signal }) => await listBoardDepartures({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true
    }),
    queryKey: listBoardDeparturesQueryKey(options)
});

export const listBoardArrivalsQueryKey = (options: Options<ListBoardArrivalsData>) => createQueryKey('listBoardArrivals', options);

/**
 * Get all arrivals within a specified timespan at a specified point
 *
 * Lists all journeys that are arriving at the specified point on the specified server within the given time span.
 * By default, a time span of 30 minutes is returned, starting at the current server time, unless otherwise specified.
 * Results are sorted by realtime time information by default. A minimum time span of 5 minutes and a maximum time
 * span of 6 hours can be requested. The start time can be 1 day in the future and 90 days in the past.
 *
 */
export const listBoardArrivalsOptions = (options: Options<ListBoardArrivalsData>) => queryOptions<ListBoardArrivalsResponse, ListBoardArrivalsError, ListBoardArrivalsResponse, ReturnType<typeof listBoardArrivalsQueryKey>>({
    queryFn: async ({ queryKey, signal }) => await listBoardArrivals({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true
    }),
    queryKey: listBoardArrivalsQueryKey(options)
});
