// This file is auto-generated by @hey-api/openapi-ts

export type SimRailUserDto = {
    /**
     * The id of the steam profile
     */
    id: string;
    /**
     * The name of the steam profile
     */
    name: string;
    /**
     * The avatar hash of the profile, can be used to retrieve the image from Steam
     */
    avatarHash: string;
    /**
     * The url to the profile
     */
    profileUrl: string;
    /**
     * The ISO 3166-1 alpha-2 country code where the user resides, null if not visible or set
     */
    countryCode?: string | null;
    /**
     * Indicates if the steam profile page is publicly visible
     */
    profileVisible: boolean;
};

export type RailcarDto = {
    /**
     * The unique identifier of the railcar
     */
    id: string;
    /**
     * The display name of the railcar
     */
    name: string;
    /**
     * The grouping type of the railcar
     */
    type: 'WAGON' | 'LOCOMOTIVE' | 'ELECTRIC_MULTIPLE_UNIT';
    /**
     * The type identifier of the railcar
     */
    typeIdentifier: string;
    /**
     * The id of the DLC that is required for the railcar, null if included in the base game
     */
    requiredDlcId?: string | null;
    /**
     * The designation of the railcar
     */
    designation: string;
    /**
     * The producer of the railcar
     */
    producer: string;
    /**
     * The years in which the railcar was produced, can be range or single year
     */
    productionYears: string;
    /**
     * The weight of the railcar in tons
     */
    weight: number;
    /**
     * The width of the railcar in meters
     */
    width: number;
    /**
     * The length of the railcar in meters
     */
    length: number;
    /**
     * The maximum allowed speed of the railcar
     */
    maxSpeed: number;
};

export type PointGeoPositionDto = {
    /**
     * The latitude of the position
     */
    latitude: number;
    /**
     * The longitude of the position
     */
    longitude: number;
};

export type PointInfoDto = {
    /**
     * The id of the point
     */
    id: string;
    /**
     * The name of the point
     */
    name: string;
    /**
     * The ISO 3166-1 alpha-3 country code where the point is located
     */
    country: string;
    /**
     * The position where the point located
     */
    position: PointGeoPositionDto;
    /**
     * The UIC reference of the point, might not null in case it is unknown
     */
    uicRef?: string | null;
    /**
     * The OSM node id of the point
     */
    osmNodeId: number;
    /**
     * The maximum speed any journey can drive at the point
     */
    maxSpeed: number;
    /**
     * Indicates if the point is a stop place (without switches) or a full station
     */
    stopPlace: boolean;
    /**
     * The platforms at the point at which a passenger change can happen
     */
    platforms: Array<PointPlatformInfoDto>;
};

export type PointPlatformInfoDto = {
    /**
     * The track where the platform is located
     */
    track: number;
    /**
     * The number of the platform
     */
    platform: number;
};

export type JourneyDto = {
    /**
     * The identifier of the journey
     */
    journeyId: string;
    /**
     * The identifier of the server where the journey takes place
     */
    serverId: string;
    /**
     * The time (ISO-8601 with offset) when the journey data was last updated
     */
    lastUpdated: string;
    /**
     * The time (ISO-8601 with offset) when the journey was first seen, null if the journey wasn't active yet
     */
    firstSeenTime?: string | null;
    /**
     * The time (ISO-8601 with offset) when the journey was last seen, null if the journey is still or wasn't active
     */
    lastSeenTime?: string | null;
    /**
     * Indicates if the journey was cancelled
     */
    journeyCancelled: boolean;
    /**
     * Current live information about the journey, omitted from the response if the journey is not active
     */
    liveData?: JourneyLiveDataDto;
    /**
     * The events along the route of the journey
     */
    events: Array<JourneyEventDto>;
};

export type JourneyEventDto = {
    /**
     * The id of the event
     */
    id: string;
    /**
     * The type of the event
     */
    type: 'ARRIVAL' | 'DEPARTURE';
    /**
     * Indicates if the event was cancelled, note that events can be additional and cancelled
     */
    cancelled: boolean;
    /**
     * Indicates if the event is additional (not part of the scheduled route)
     */
    additional: boolean;
    /**
     * Information about the stop place where the event takes place
     */
    stopPlace: JourneyStopPlaceDto;
    /**
     * Scheduled time of the event (ISO-8601 with offset)
     */
    scheduledTime: string;
    /**
     * Best known time of the event (ISO-8601 with offset), precision is described by the time type field
     */
    realtimeTime: string;
    /**
     * The precision of the realtime time of the event
     */
    realtimeTimeType: 'SCHEDULE' | 'PREDICTION' | 'REAL';
    /**
     * The scheduled stop type for the journey at the event
     */
    stopType: 'NONE' | 'TECHNICAL' | 'PASSENGER';
    /**
     * Information about the scheduled passenger stop, omitted if no passenger stop is scheduled
     */
    scheduledPassengerStop?: JourneyStopInfoDto;
    /**
     * Realtime information about the passenger stop, omitted if the event didn't happen / didn't stop at a platform
     */
    realtimePassengerStop?: JourneyStopInfoDto;
    /**
     * Information about the transport at the event
     */
    transport: JourneyTransportDto;
};

export type JourneyGeoPositionDto = {
    /**
     * The latitude of the position
     */
    latitude: number;
    /**
     * The longitude of the position
     */
    longitude: number;
};

export type JourneyLiveDataDto = {
    /**
     * The current, rounded speed of the journey
     */
    speed: number;
    /**
     * The current position of the journey
     */
    position: JourneyGeoPositionDto;
    /**
     * The steam id of the current driver
     */
    driverSteamId?: string | null;
    /**
     * The signal in front of the journey, null in case it is too far away or doesn't exist
     */
    nextSignal?: JourneySignalDto;
};

export type JourneySignalDto = {
    /**
     * The id (name) of the signal
     */
    name: string;
    /**
     * The allowed speed of passing the signal, null in case it shows a Vmax aspect
     */
    maxSpeed?: number | null;
    /**
     * The distance of the journey to the signal, in 10 meter steps
     */
    distance: number;
};

export type JourneyStopInfoDto = {
    /**
     * The platform of the passenger change
     */
    platform: number;
    /**
     * The track of the passenger change
     */
    track: number;
};

export type JourneyStopPlaceDto = {
    /**
     * The id of the stop place
     */
    id: string;
    /**
     * The name of the stop place
     */
    name: string;
    /**
     * The position where the stop place is located
     */
    position: JourneyGeoPositionDto;
    /**
     * Indicates if the point is a stop place (without switches) or a full station
     */
    stopPlace: boolean;
    /**
     * If the stop place is within the playable border of the map
     */
    inPlayableBorder: boolean;
};

export type JourneyTransportDto = {
    /**
     * The external category of the transport
     */
    category: string;
    /**
     * The number of the transport
     */
    number: string;
    /**
     * The line of the transport, null in case no line is associated with the transport
     */
    line?: string | null;
    /**
     * The label of the transport, for example the marketing name or product name of the transport
     */
    label?: string | null;
    /**
     * The higher-level category of the transport
     */
    type: 'NATIONAL_EXPRESS_TRAIN' | 'INTER_NATIONAL_EXPRESS_TRAIN' | 'INTER_REGIONAL_EXPRESS_TRAIN' | 'INTER_REGIONAL_TRAIN' | 'REGIONAL_FAST_TRAIN' | 'REGIONAL_TRAIN' | 'ADDITIONAL_TRAIN' | 'MANEUVER_TRAIN' | 'EMPTY_TRANSFER_TRAIN' | 'INTER_NATIONAL_CARGO_TRAIN' | 'NATIONAL_CARGO_TRAIN' | 'MAINTENANCE_TRAIN';
    /**
     * The maximum speed (in km/h) of the journey is allowed to drive at the associated point
     */
    maxSpeed: number;
};

export type VehicleCompositionDto = {
    /**
     * The id of the journey associated with the vehicle composition
     */
    journeyId: string;
    /**
     * The status of the vehicle composition
     */
    status: 'REAL' | 'PREDICTION' | 'UNKNOWN';
    /**
     * The time (ISO-8601 with offset) when the vehicle data was last updated
     */
    lastUpdated: string;
    /**
     * The vehicles that are in the composition
     */
    vehicles: Array<VehicleDto>;
};

export type VehicleDto = {
    /**
     * The index (0 based) where the vehicle is located in the composition
     */
    indexInGroup: number;
    /**
     * The load weight of the vehicle, can be null in case nothing is loaded
     */
    loadWeight?: number | null;
    /**
     * The load of the vehicle, can be null in case nothing is loaded
     */
    load?: 'TIE' | 'T_BEAM' | 'PIPELINE' | 'CONTAINER' | 'TREE_TRUNK' | 'WOODEN_BEAM' | 'METAL_SHEET' | 'STEEL_CIRCLE' | 'CONCRETE_SLAB' | 'GAS_CONTAINER' | 'PETROL' | 'ETHANOL' | 'CRUDE_OIL' | 'HEATING_OIL' | 'COAL' | 'SAND' | 'BALLAST' | 'WOOD_LOGS' | 'UNKNOWN';
    /**
     * Summary information about the railcar used for this vehicle
     */
    railcar: VehicleRailcarSummaryDto;
};

export type VehicleRailcarSummaryDto = {
    /**
     * The unique identifier of the railcar
     */
    id: string;
    /**
     * The display name of the railcar
     */
    name: string;
    /**
     * The grouping type of the railcar
     */
    type: 'WAGON' | 'LOCOMOTIVE' | 'ELECTRIC_MULTIPLE_UNIT';
    /**
     * The weight of the railcar in tons
     */
    weight: number;
    /**
     * The width of the railcar in meters
     */
    width: number;
    /**
     * The length of the railcar in meters
     */
    length: number;
};

export type SimRailServerDto = {
    /**
     * The id of the server
     */
    id: string;
    /**
     * The code of the server
     */
    code: string;
    /**
     * The timezone id of the server according to the ISO-8601 specification
     */
    timezoneId: string;
    /**
     * The difference in hours between the UTC time and the time on the server
     */
    utcOffsetHours: number;
    /**
     * The region where the server is located
     */
    region: 'ASIA' | 'EUROPE' | 'US_NORTH';
    /**
     * Tags of the server, for example providing detail information about the moderation status
     */
    tags: Array<string>;
    /**
     * The language spoken on the server, null if the server is international and not specialised
     */
    spokenLanguage?: string | null;
    /**
     * The scenery (map part) that is available on the server
     */
    scenery: 'FULL' | 'WARSAW_LODZ_PSARY' | 'WARSAW_LODZ_KRAKOW' | 'WARSAW_LODZ_KATOWICE' | 'WARSAW_KATOWICE_KRAKOW';
    /**
     * The time (ISO-8601 with offset) when the data of the server was last updated
     */
    lastUpdated: string;
    /**
     * The time (ISO-8601 with offset) when the server was initially registered in the SimRail backend
     */
    registeredSince: string;
    /**
     * If the server was online during the last collection
     */
    online: boolean;
    /**
     * If the server is no longer registered in the SimRail backend
     */
    deleted: boolean;
};

export type PaginatedResponseDtoPointInfoDto = {
    /**
     * The items that are one the requested page
     */
    items: Array<PointInfoDto>;
    /**
     * Indicates if more pages are available and can be loaded
     */
    morePages: boolean;
};

export type MapJourneyRouteDto = {
    /**
     * The id of the journey to which the waypoints apply
     */
    journeyId: string;
    /**
     * The stops along the journey route
     */
    stops: Array<JourneyStopPlaceDto>;
    /**
     * The waypoints along the journey route
     */
    polyline: Array<MapPolylineEntryDto>;
};

export type MapPolylineEntryDto = {
    /**
     * The latitude of the position
     */
    latitude: number;
    /**
     * The longitude of the position
     */
    longitude: number;
    /**
     * The elevation of th position
     */
    elevation: number;
};

export type JourneyStopPlaceSummaryDto = {
    /**
     * The id of the stop place
     */
    id: string;
    /**
     * The name of the stop place
     */
    name: string;
    /**
     * If the stop place is within the playable border of the map
     */
    inPlayableBorder: boolean;
};

export type JourneySummaryDto = {
    /**
     * The identifier of the journey
     */
    journeyId: string;
    /**
     * The identifier of the server where the journey takes place
     */
    serverId: string;
    /**
     * The time (ISO-8601 with offset) when the journey was first seen, null if the journey wasn't active yet
     */
    firstSeenTime?: string | null;
    /**
     * The time (ISO-8601 with offset) when the journey was last seen, null if the journey is still or wasn't active
     */
    lastSeenTime?: string | null;
    /**
     * Indicates if the journey was cancelled
     */
    journeyCancelled: boolean;
    /**
     * The origin (first) event of the journey
     */
    originEvent: JourneyTerminalEventDto;
    /**
     * The destination (last) event of the journey
     */
    destinationEvent: JourneyTerminalEventDto;
};

export type JourneyTerminalEventDto = {
    /**
     * The stop place associated with the event
     */
    stopPlace: JourneyStopPlaceSummaryDto;
    /**
     * The scheduled time (ISO-8601 with offset) of the event
     */
    scheduledTime: string;
    /**
     * The transport used at the event
     */
    transport: JourneyTransportSummaryDto;
    /**
     * Indicates if the event was cancelled
     */
    cancelled: boolean;
};

export type JourneyTransportSummaryDto = {
    /**
     * The external category of the transport
     */
    category: string;
    /**
     * The number of the transport
     */
    number: string;
    /**
     * The line of the transport, null in case no line is associated with the transport
     */
    line?: string | null;
    /**
     * The label of the transport, for example the marketing name or product name of the transport
     */
    label?: string | null;
    /**
     * The higher-level category of the transport
     */
    type: 'NATIONAL_EXPRESS_TRAIN' | 'INTER_NATIONAL_EXPRESS_TRAIN' | 'INTER_REGIONAL_EXPRESS_TRAIN' | 'INTER_REGIONAL_TRAIN' | 'REGIONAL_FAST_TRAIN' | 'REGIONAL_TRAIN' | 'ADDITIONAL_TRAIN' | 'MANEUVER_TRAIN' | 'EMPTY_TRANSFER_TRAIN' | 'INTER_NATIONAL_CARGO_TRAIN' | 'NATIONAL_CARGO_TRAIN' | 'MAINTENANCE_TRAIN';
};

export type PaginatedResponseDtoJourneySummaryDto = {
    /**
     * The items that are one the requested page
     */
    items: Array<JourneySummaryDto>;
    /**
     * Indicates if more pages are available and can be loaded
     */
    morePages: boolean;
};

export type JourneyEventDescriptorDto = {
    /**
     * The stop place associated with the event
     */
    stopPlace: JourneyStopPlaceSummaryDto;
    /**
     * The scheduled time (ISO-8601 with offset) of the event
     */
    scheduledTime: string;
    /**
     * Indicates if the event was cancelled
     */
    cancelled: boolean;
};

export type JourneySummaryWithPlayableEventDto = {
    /**
     * The identifier of the journey
     */
    journeyId: string;
    /**
     * The identifier of the server where the journey takes place
     */
    serverId: string;
    /**
     * The time (ISO-8601 with offset) when the journey was first seen, null if the journey wasn't active yet
     */
    firstSeenTime?: string | null;
    /**
     * The time (ISO-8601 with offset) when the journey was last seen, null if the journey is still or wasn't active
     */
    lastSeenTime?: string | null;
    /**
     * Indicates if the journey was cancelled
     */
    journeyCancelled: boolean;
    /**
     * The origin (first) event of the journey
     */
    originEvent: JourneyTerminalEventDto;
    /**
     * The destination (last) event of the journey
     */
    destinationEvent: JourneyTerminalEventDto;
    /**
     * The first event that is within the playable map border of the journey
     */
    firstPlayableEvent: JourneyEventDescriptorDto;
};

export type PaginatedResponseDtoJourneySummaryWithPlayableEventDto = {
    /**
     * The items that are one the requested page
     */
    items: Array<JourneySummaryWithPlayableEventDto>;
    /**
     * Indicates if more pages are available and can be loaded
     */
    morePages: boolean;
};

export type JourneyActiveDto = {
    /**
     * The identifier of the journey
     */
    journeyId: string;
    /**
     * The identifier of the server where the journey is active
     */
    serverId: string;
    /**
     * Information about the transport at the first event of the journey
     */
    transport: JourneyActiveTransportDto;
    /**
     * The steam id of the current driver
     */
    driverSteamId?: string | null;
    /**
     * The current, rounded speed of the journey
     */
    speed: number;
    /**
     * The current position of the journey
     */
    position: JourneyGeoPositionDto;
};

export type JourneyActiveTransportDto = {
    /**
     * The category of the journey
     */
    category: string;
    /**
     * The number of the journey
     */
    number: string;
    /**
     * The line of the journey
     */
    line?: string | null;
    /**
     * The label of the journey
     */
    label?: string | null;
};

export type DispatchPointGeoPositionDto = {
    /**
     * The latitude of the position
     */
    latitude: number;
    /**
     * The longitude of the position
     */
    longitude: number;
};

export type DispatchPostInfoDto = {
    /**
     * The id of the dispatch post
     */
    id: string;
    /**
     * The name of the dispatch post
     */
    name: string;
    /**
     * The id of the point where the dispatch post is located
     */
    pointId: string;
    /**
     * The id of the server for which the dispatch post info is valid
     */
    serverId: string;
    /**
     * The time (ISO-8601 with offset) when the dispatch post was last updated
     */
    lastUpdated: string;
    /**
     * The time (ISO-8601 with offset) when the dispatch post was registered in the SimRail backend
     */
    registeredSince: string;
    /**
     * The position where the dispatch post is located
     */
    position: DispatchPointGeoPositionDto;
    /**
     * A list of image urls displaying the dispatch post
     */
    images: Array<string>;
    /**
     * A list of steam ids of the users that are currently dispatching the dispatch post
     */
    dispatchers: Array<string>;
    /**
     * The difficulty rating of the dispatch post, from 1 (easy) to 5 (hard)
     */
    difficulty: number;
    /**
     * Indicates if the dispatch post was deleted in the SimRail backend
     */
    deleted: boolean;
};

export type PaginatedResponseDtoDispatchPostInfoDto = {
    /**
     * The items that are one the requested page
     */
    items: Array<DispatchPostInfoDto>;
    /**
     * Indicates if more pages are available and can be loaded
     */
    morePages: boolean;
};

export type BoardEntryDto = {
    /**
     * The id of the journey arriving/departing at/from the requested point
     */
    journeyId: string;
    /**
     * The id of the arrival/departure event at the requested point
     */
    eventId: string;
    /**
     * Indicates if the event was cancelled, note that events can be additional and cancelled
     */
    cancelled: boolean;
    /**
     * Indicates if the event is additional (not part of the scheduled route)
     */
    additional: boolean;
    /**
     * Scheduled time of the event (ISO-8601 with offset)
     */
    scheduledTime: string;
    /**
     * Best known time of the event (ISO-8601 with offset), precision is described by the time type field
     */
    realtimeTime: string;
    /**
     * The precision of the realtime time of the event
     */
    realtimeTimeType: 'SCHEDULE' | 'PREDICTION' | 'REAL';
    /**
     * The scheduled stop type for the journey at the event
     */
    stopType: 'NONE' | 'TECHNICAL' | 'PASSENGER';
    /**
     * Information about the scheduled passenger stop, omitted if no passenger stop is scheduled
     */
    scheduledPassengerStop?: BoardStopInfoDto;
    /**
     * Realtime information about the passenger stop, omitted if the event didn't happen / didn't stop at a platform
     */
    realtimePassengerStop?: BoardStopInfoDto;
    /**
     * Information about the transport at the requested point
     */
    transport: BoardTransportDto;
    /**
     * The events this journey goes via. For arrivals these are the events before the requested point, for departures the
     * events after the requested point. Events are always sorted by their index along the journey route. This means for
     * arrivals the events are ordered in [initial -> current] while for departures they are sorted [current -> final].
     *
     */
    via: Array<BoardViaEventDto>;
};

export type BoardStopInfoDto = {
    /**
     * The platform of the passenger change
     */
    platform: number;
    /**
     * The track of the passenger change
     */
    track: number;
};

export type BoardTransportDto = {
    /**
     * The external category of the transport
     */
    category: string;
    /**
     * The number of the transport
     */
    number: string;
    /**
     * The line of the transport, null in case no line is associated with the transport
     */
    line?: string | null;
    /**
     * The label of the transport, for example the marketing name or product name of the transport
     */
    label?: string | null;
    /**
     * The higher-level category of the transport
     */
    type: 'NATIONAL_EXPRESS_TRAIN' | 'INTER_NATIONAL_EXPRESS_TRAIN' | 'INTER_REGIONAL_EXPRESS_TRAIN' | 'INTER_REGIONAL_TRAIN' | 'REGIONAL_FAST_TRAIN' | 'REGIONAL_TRAIN' | 'ADDITIONAL_TRAIN' | 'MANEUVER_TRAIN' | 'EMPTY_TRANSFER_TRAIN' | 'INTER_NATIONAL_CARGO_TRAIN' | 'NATIONAL_CARGO_TRAIN' | 'MAINTENANCE_TRAIN';
    /**
     * The maximum speed (in km/h) of the journey is allowed to drive at the associated point
     */
    maxSpeed: number;
};

export type BoardViaEventDto = {
    /**
     * Id of the point
     */
    pointId: string;
    /**
     * Name of the point
     */
    pointName: string;
    /**
     * If the particular point was cancelled
     */
    cancelled: boolean;
    /**
     * If the particular point is additional
     */
    additional: boolean;
    /**
     * If a passenger change is scheduled at the point
     */
    passengerChange: boolean;
};

/**
 * Problem description according to RFC 9457
 */
export type ProblemDetail = {
    /**
     * A URI reference identifying the problem type
     */
    type?: string;
    /**
     * The HTTP status code generated by the server for the problem
     */
    status?: number;
    /**
     * A human-readable summary of the problem type
     */
    title?: string;
    /**
     * A human-readable explanation specific to the occurrence of the problem
     */
    detail?: string;
    /**
     * A URI reference that identifies the specific occurrence of the problem
     */
    instance?: string;
    [key: string]: unknown | string | number | undefined;
};

export type FindUsersBySteamIdsData = {
    /**
     * An array containing the steam ids of the users to resolve
     */
    body: Array<string>;
    path?: never;
    query?: never;
    url: '/sit-users/v1/by-steam-ids';
};

export type FindUsersBySteamIdsErrors = {
    /**
     * One of the given steam ids is in an incorrect format
     */
    400: ProblemDetail;
    /**
     * An internal error occurred while processing the request
     */
    500: ProblemDetail;
};

export type FindUsersBySteamIdsError = FindUsersBySteamIdsErrors[keyof FindUsersBySteamIdsErrors];

export type FindUsersBySteamIdsResponses = {
    /**
     * The users that were successfully resolved based on the given input ids
     */
    200: Array<SimRailUserDto>;
};

export type FindUsersBySteamIdsResponse = FindUsersBySteamIdsResponses[keyof FindUsersBySteamIdsResponses];

export type FindRailcarsByIdsData = {
    /**
     * An array containing the ids of the railcars to resolve
     */
    body: Array<string>;
    path?: never;
    query?: never;
    url: '/sit-railcars/v1/by-ids';
};

export type FindRailcarsByIdsErrors = {
    /**
     * One of the filter parameters is invalid
     */
    400: ProblemDetail;
    /**
     * An internal error occurred while processing the request
     */
    500: ProblemDetail;
};

export type FindRailcarsByIdsError = FindRailcarsByIdsErrors[keyof FindRailcarsByIdsErrors];

export type FindRailcarsByIdsResponses = {
    /**
     * The railcars that were successfully resolved based on the given input ids
     */
    200: Array<RailcarDto>;
};

export type FindRailcarsByIdsResponse = FindRailcarsByIdsResponses[keyof FindRailcarsByIdsResponses];

export type FindPointsByIdData = {
    /**
     * An array containing the ids of the points to resolve
     */
    body: Array<string>;
    path?: never;
    query?: never;
    url: '/sit-points/v1/by-ids';
};

export type FindPointsByIdErrors = {
    /**
     * One of the filter parameters is invalid
     */
    400: ProblemDetail;
    /**
     * An internal error occurred while processing the request
     */
    500: ProblemDetail;
};

export type FindPointsByIdError = FindPointsByIdErrors[keyof FindPointsByIdErrors];

export type FindPointsByIdResponses = {
    /**
     * The points that were successfully resolved based on the given input ids
     */
    200: Array<PointInfoDto>;
};

export type FindPointsByIdResponse = FindPointsByIdResponses[keyof FindPointsByIdResponses];

export type FindJourneysByIdsData = {
    /**
     * An array containing the ids of the journeys to resolve
     */
    body: Array<string>;
    path?: never;
    query?: never;
    url: '/sit-journeys/v1/by-ids';
};

export type FindJourneysByIdsErrors = {
    /**
     * One of the filter parameters is invalid
     */
    400: ProblemDetail;
    /**
     * An internal error occurred while processing the request
     */
    500: ProblemDetail;
};

export type FindJourneysByIdsError = FindJourneysByIdsErrors[keyof FindJourneysByIdsErrors];

export type FindJourneysByIdsResponses = {
    /**
     * The journeys that were successfully resolved based on the given input ids
     */
    200: Array<JourneyDto>;
};

export type FindJourneysByIdsResponse = FindJourneysByIdsResponses[keyof FindJourneysByIdsResponses];

export type FindVehicleCompositionByJourneyIdData = {
    body?: never;
    headers?: {
        /**
         * If provided the response body is empty in case the data didn't change since the given date
         */
        'If-Modified-Since'?: string;
    };
    path: {
        /**
         * The id of the journey to get the vehicle composition of
         */
        id: string;
    };
    query?: never;
    url: '/sit-vehicles/v1/by-journey/{id}';
};

export type FindVehicleCompositionByJourneyIdErrors = {
    /**
     * The given journey id is invalid
     */
    400: ProblemDetail;
    /**
     * No vehicle sequence for the journey with the given id is known
     */
    404: unknown;
    /**
     * An internal error occurred while processing the request
     */
    500: ProblemDetail;
};

export type FindVehicleCompositionByJourneyIdError = FindVehicleCompositionByJourneyIdErrors[keyof FindVehicleCompositionByJourneyIdErrors];

export type FindVehicleCompositionByJourneyIdResponses = {
    /**
     * The vehicle sequence for the journey with the given id was successfully resolved
     */
    200: VehicleCompositionDto;
};

export type FindVehicleCompositionByJourneyIdResponse = FindVehicleCompositionByJourneyIdResponses[keyof FindVehicleCompositionByJourneyIdResponses];

export type FindServerByIdData = {
    body?: never;
    headers?: {
        /**
         * If provided the response body is empty in case the data didn't change since the given date
         */
        'If-Modified-Since'?: string;
    };
    path: {
        /**
         * The id of the server to get
         */
        id: string;
    };
    query?: never;
    url: '/sit-servers/v1/by-id/{id}';
};

export type FindServerByIdErrors = {
    /**
     * The given server ID is invalid
     */
    400: ProblemDetail;
    /**
     * No server with the given ID was found
     */
    404: unknown;
    /**
     * An internal error occurred while processing the request
     */
    500: ProblemDetail;
};

export type FindServerByIdError = FindServerByIdErrors[keyof FindServerByIdErrors];

export type FindServerByIdResponses = {
    /**
     * The server was successfully resolved based on the given id
     */
    200: SimRailServerDto;
};

export type FindServerByIdResponse = FindServerByIdResponses[keyof FindServerByIdResponses];

export type FindServerByCodeData = {
    body?: never;
    headers?: {
        /**
         * If provided the response body is empty in case the data didn't change since the given date
         */
        'If-Modified-Since'?: string;
    };
    path: {
        /**
         * The code of the server to get
         */
        code: string;
    };
    query?: never;
    url: '/sit-servers/v1/by-code/{code}';
};

export type FindServerByCodeErrors = {
    /**
     * The given server code is invalid
     */
    400: ProblemDetail;
    /**
     * No server with the given code was found
     */
    404: unknown;
    /**
     * An internal error occurred while processing the request
     */
    500: ProblemDetail;
};

export type FindServerByCodeError = FindServerByCodeErrors[keyof FindServerByCodeErrors];

export type FindServerByCodeResponses = {
    /**
     * The server was successfully resolved based on the given server code
     */
    200: SimRailServerDto;
};

export type FindServerByCodeResponse = FindServerByCodeResponses[keyof FindServerByCodeResponses];

export type ListServersData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * If servers that are offline should be included in the response
         */
        includeOffline?: boolean;
        /**
         * If servers that are deleted should be included in the response
         */
        includeDeleted?: boolean;
    };
    url: '/sit-servers/v1/';
};

export type ListServersErrors = {
    /**
     * One of the given filter parameters is invalid
     */
    400: ProblemDetail;
    /**
     * An internal error occurred while processing the request
     */
    500: ProblemDetail;
};

export type ListServersError = ListServersErrors[keyof ListServersErrors];

export type ListServersResponses = {
    /**
     * The servers were successfully resolved based on the given filter parameters
     */
    200: Array<SimRailServerDto>;
};

export type ListServersResponse = ListServersResponses[keyof ListServersResponses];

export type FindRailcarByApiNameData = {
    body?: never;
    path?: never;
    query: {
        /**
         * The SimRail api id of the railcar to get the data of
         */
        id: string;
    };
    url: '/sit-railcars/v1/by-simrail-id';
};

export type FindRailcarByApiNameErrors = {
    /**
     * One of the filter parameters is invalid
     */
    400: ProblemDetail;
    /**
     * No railcar can be found with the given id
     */
    404: unknown;
    /**
     * An internal error occurred while processing the request
     */
    500: ProblemDetail;
};

export type FindRailcarByApiNameError = FindRailcarByApiNameErrors[keyof FindRailcarByApiNameErrors];

export type FindRailcarByApiNameResponses = {
    /**
     * The railcar with the given id was successfully resolved
     */
    200: RailcarDto;
};

export type FindRailcarByApiNameResponse = FindRailcarByApiNameResponses[keyof FindRailcarByApiNameResponses];

export type FindRailcarByIdData = {
    body?: never;
    path: {
        /**
         * The id of the railcar to get the data of
         */
        id: string;
    };
    query?: never;
    url: '/sit-railcars/v1/by-id/{id}';
};

export type FindRailcarByIdErrors = {
    /**
     * One of the filter parameters is invalid
     */
    400: ProblemDetail;
    /**
     * No railcar can be found with the given id
     */
    404: unknown;
    /**
     * An internal error occurred while processing the request
     */
    500: ProblemDetail;
};

export type FindRailcarByIdError = FindRailcarByIdErrors[keyof FindRailcarByIdErrors];

export type FindRailcarByIdResponses = {
    /**
     * The railcar with the given id was successfully resolved
     */
    200: RailcarDto;
};

export type FindRailcarByIdResponse = FindRailcarByIdResponses[keyof FindRailcarByIdResponses];

export type FindPointByPositionData = {
    body?: never;
    path?: never;
    query: {
        /**
         * Latitude from which to search in the given radius
         */
        latitude: number;
        /**
         * Longitude from which to search in the given radius
         */
        longitude: number;
        /**
         * The radius to search around  position, in meters (defaults to 200m)
         */
        radius?: number;
        /**
         * Optional list of countries in which the points may be located
         */
        countries?: Array<string>;
        /**
         * The maximum results to return (between 1 and 25, defaults to 10)
         */
        limit?: number;
    };
    url: '/sit-points/v1/by-position';
};

export type FindPointByPositionErrors = {
    /**
     * One of the filter parameters is invalid
     */
    400: ProblemDetail;
    /**
     * An internal error occurred while processing the request
     */
    500: ProblemDetail;
};

export type FindPointByPositionError = FindPointByPositionErrors[keyof FindPointByPositionErrors];

export type FindPointByPositionResponses = {
    /**
     * The search was successfully executed based on the given filter parameters
     */
    200: Array<PointInfoDto>;
};

export type FindPointByPositionResponse = FindPointByPositionResponses[keyof FindPointByPositionResponses];

export type FindPointBySimRailPointIdData = {
    body?: never;
    path: {
        /**
         * The id of the point in the SimRail backend, e.g. 2371
         */
        id: string;
    };
    query?: never;
    url: '/sit-points/v1/by-point-id/{id}';
};

export type FindPointBySimRailPointIdErrors = {
    /**
     * One of the filter parameters is invalid
     */
    400: ProblemDetail;
    /**
     * No point can be found with the given id
     */
    404: unknown;
    /**
     * An internal error occurred while processing the request
     */
    500: ProblemDetail;
};

export type FindPointBySimRailPointIdError = FindPointBySimRailPointIdErrors[keyof FindPointBySimRailPointIdErrors];

export type FindPointBySimRailPointIdResponses = {
    /**
     * The point with the given id was successfully resolved
     */
    200: PointInfoDto;
};

export type FindPointBySimRailPointIdResponse = FindPointBySimRailPointIdResponses[keyof FindPointBySimRailPointIdResponses];

export type FindPointByNameData = {
    body?: never;
    path: {
        /**
         * The search query for the point (must be between 3 and 35 chars)
         */
        searchQuery: string;
    };
    query?: {
        /**
         * Optional list of countries in which the points may be located
         */
        countries?: Array<string>;
        /**
         * The maximum results to return (between 1 and 25, defaults to 10)
         */
        limit?: number;
    };
    url: '/sit-points/v1/by-name/{searchQuery}';
};

export type FindPointByNameErrors = {
    /**
     * One of the filter parameters is invalid
     */
    400: ProblemDetail;
    /**
     * An internal error occurred while processing the request
     */
    500: ProblemDetail;
};

export type FindPointByNameError = FindPointByNameErrors[keyof FindPointByNameErrors];

export type FindPointByNameResponses = {
    /**
     * The search was successfully executed based on the given search query
     */
    200: Array<PointInfoDto>;
};

export type FindPointByNameResponse = FindPointByNameResponses[keyof FindPointByNameResponses];

export type FindPointByIdData = {
    body?: never;
    path: {
        /**
         * The id of the point to get the data of
         */
        id: string;
    };
    query?: never;
    url: '/sit-points/v1/by-id/{id}';
};

export type FindPointByIdErrors = {
    /**
     * One of the filter parameters is invalid
     */
    400: ProblemDetail;
    /**
     * No point can be found with the given id
     */
    404: unknown;
    /**
     * An internal error occurred while processing the request
     */
    500: ProblemDetail;
};

export type FindPointByIdError = FindPointByIdErrors[keyof FindPointByIdErrors];

export type FindPointByIdResponses = {
    /**
     * The point with the given id was successfully resolved
     */
    200: PointInfoDto;
};

export type FindPointByIdResponse = FindPointByIdResponses[keyof FindPointByIdResponses];

export type ListPointsData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Optional list of countries in which the points may be located
         */
        countries?: Array<string>;
        /**
         * The page of elements to return, defaults to 1
         */
        page?: number;
        /**
         * The maximum items to return per page, defaults to 20
         */
        limit?: number;
    };
    url: '/sit-points/v1/';
};

export type ListPointsErrors = {
    /**
     * One of the filter parameters is invalid
     */
    400: ProblemDetail;
    /**
     * An internal error occurred while processing the request
     */
    500: ProblemDetail;
};

export type ListPointsError = ListPointsErrors[keyof ListPointsErrors];

export type ListPointsResponses = {
    /**
     * The points were successfully resolved based on the given filter parameters
     */
    200: PaginatedResponseDtoPointInfoDto;
};

export type ListPointsResponse = ListPointsResponses[keyof ListPointsResponses];

export type FindMapPolylineByJourneyData = {
    body?: never;
    headers?: {
        /**
         * Sets the content type to return, defaults to application/json but can be set
         * to application/geo+json to get the polyline as a geojson feature collection
         *
         */
        Accept?: 'application/json' | 'application/geo+json';
    };
    path: {
        /**
         * The id of the journey to get the polyline for
         */
        id: string;
    };
    query?: {
        /**
         * If cancelled events should be included in the polyline
         */
        includeCancelled?: boolean;
        /**
         * If additional events should be included in the polyline
         */
        includeAdditional?: boolean;
    };
    url: '/sit-maps/v1/polyline/by-journey/{id}';
};

export type FindMapPolylineByJourneyErrors = {
    /**
     * One of the filter parameters is invalid
     */
    400: ProblemDetail;
    /**
     * No journey can be found with the given journey id
     */
    404: unknown;
    /**
     * An internal error occurred while processing the request
     */
    500: ProblemDetail;
};

export type FindMapPolylineByJourneyError = FindMapPolylineByJourneyErrors[keyof FindMapPolylineByJourneyErrors];

export type FindMapPolylineByJourneyResponses = {
    /**
     * The polyline for the requested journey was successfully resolved
     */
    200: MapJourneyRouteDto;
};

export type FindMapPolylineByJourneyResponse = FindMapPolylineByJourneyResponses[keyof FindMapPolylineByJourneyResponses];

export type FindJourneysByRailcarData = {
    body?: never;
    path?: never;
    query: {
        /**
         * The page of elements to return, defaults to 1
         */
        page?: number;
        /**
         * The maximum items to return per page, defaults to 20
         */
        limit?: number;
        /**
         * The id of the server to filter journeys on
         */
        serverId: string;
        /**
         * The date of an event (ISO-8601 without timezone), defaults to the current server date if omitted
         */
        date?: string;
        /**
         * The id of the railcar that must be included in the vehicle composition of the journey
         */
        railcar: string;
    };
    url: '/sit-journeys/v1/by-vehicle';
};

export type FindJourneysByRailcarErrors = {
    /**
     * One of the filter parameters is invalid or doesn't match the described grouping requirements
     */
    400: ProblemDetail;
    /**
     * An internal error occurred while processing the request
     */
    500: ProblemDetail;
};

export type FindJourneysByRailcarError = FindJourneysByRailcarErrors[keyof FindJourneysByRailcarErrors];

export type FindJourneysByRailcarResponses = {
    /**
     * The journeys were successfully resolved based on the given filter parameters
     */
    200: PaginatedResponseDtoJourneySummaryDto;
};

export type FindJourneysByRailcarResponse = FindJourneysByRailcarResponses[keyof FindJourneysByRailcarResponses];

export type FindJourneysByTailData = {
    body?: never;
    path?: never;
    query: {
        /**
         * The page of elements to return, defaults to 1
         */
        page?: number;
        /**
         * The maximum items to return per page, defaults to 20
         */
        limit?: number;
        /**
         * The id of the server to filter journeys on
         */
        serverId: string;
        /**
         * The scheduled time when the journey departs from the first station
         */
        startTime: string;
        /**
         * The id of the station where the journey is scheduled to depart
         */
        startStationId: string;
        /**
         * The number of the journey at the first station
         */
        startJourneyNumber: string;
        /**
         * The category of the journey at the first station
         */
        startJourneyCategory: string;
        /**
         * The scheduled time when the journey arrives at the last station
         */
        endTime?: string;
        /**
         * The id of the station where the journey is scheduled to arrive
         */
        endStationId?: string;
    };
    url: '/sit-journeys/v1/by-tail';
};

export type FindJourneysByTailErrors = {
    /**
     * One of the filter parameters is invalid or doesn't match the described grouping requirements
     */
    400: ProblemDetail;
    /**
     * An internal error occurred while processing the request
     */
    500: ProblemDetail;
};

export type FindJourneysByTailError = FindJourneysByTailErrors[keyof FindJourneysByTailErrors];

export type FindJourneysByTailResponses = {
    /**
     * The journeys were successfully resolved based on the given filter parameters
     */
    200: PaginatedResponseDtoJourneySummaryDto;
};

export type FindJourneysByTailResponse = FindJourneysByTailResponses[keyof FindJourneysByTailResponses];

export type FindJourneysByPlayableDepartureData = {
    body?: never;
    path?: never;
    query: {
        /**
         * The page of elements to return, defaults to 1
         */
        page?: number;
        /**
         * The maximum items to return per page, defaults to 20
         */
        limit?: number;
        /**
         * The id of the server to filter journeys on
         */
        serverId: string;
        /**
         * The start of the time range (ISO-8601 with offset), defaults to the current server time if omitted
         */
        timeStart?: string;
        /**
         * The end of the time range (ISO-8601 with offset), defaults to start plus 15 minutes if omitted
         */
        timeEnd?: string;
        /**
         * The line of the journey at the first playable event
         */
        line?: string;
        /**
         * The category of the journey at the first playable event
         */
        journeyCategory?: string;
        /**
         * The transport types that are returned, defaults to all types if omitted
         */
        transportTypes?: Array<'NATIONAL_EXPRESS_TRAIN' | 'INTER_NATIONAL_EXPRESS_TRAIN' | 'INTER_REGIONAL_EXPRESS_TRAIN' | 'INTER_REGIONAL_TRAIN' | 'REGIONAL_FAST_TRAIN' | 'REGIONAL_TRAIN' | 'ADDITIONAL_TRAIN' | 'MANEUVER_TRAIN' | 'EMPTY_TRANSFER_TRAIN' | 'INTER_NATIONAL_CARGO_TRAIN' | 'NATIONAL_CARGO_TRAIN' | 'MAINTENANCE_TRAIN'>;
    };
    url: '/sit-journeys/v1/by-playable-departure';
};

export type FindJourneysByPlayableDepartureErrors = {
    /**
     * One of the filter parameters is invalid or doesn't match the described requirements
     */
    400: ProblemDetail;
    /**
     * An internal error occurred while processing the request
     */
    500: ProblemDetail;
};

export type FindJourneysByPlayableDepartureError = FindJourneysByPlayableDepartureErrors[keyof FindJourneysByPlayableDepartureErrors];

export type FindJourneysByPlayableDepartureResponses = {
    /**
     * The journeys were successfully resolved based on the given filter parameters
     */
    200: PaginatedResponseDtoJourneySummaryWithPlayableEventDto;
};

export type FindJourneysByPlayableDepartureResponse = FindJourneysByPlayableDepartureResponses[keyof FindJourneysByPlayableDepartureResponses];

export type FindJourneyByIdData = {
    body?: never;
    headers?: {
        /**
         * If provided the response body is empty in case the data didn't change since the given date
         */
        'If-Modified-Since'?: string;
    };
    path: {
        /**
         * The id of the journey to return
         */
        id: string;
    };
    query?: never;
    url: '/sit-journeys/v1/by-id/{id}';
};

export type FindJourneyByIdErrors = {
    /**
     * The given id or one of the filter parameters did not match the requirements
     */
    400: ProblemDetail;
    /**
     * No journey can be found with the given journey id
     */
    404: unknown;
    /**
     * An internal error occurred while processing the request
     */
    500: ProblemDetail;
};

export type FindJourneyByIdError = FindJourneyByIdErrors[keyof FindJourneyByIdErrors];

export type FindJourneyByIdResponses = {
    /**
     * The journey with the given id was successfully resolved
     */
    200: JourneyDto;
};

export type FindJourneyByIdResponse = FindJourneyByIdResponses[keyof FindJourneyByIdResponses];

export type FindJourneysByEventData = {
    body?: never;
    path?: never;
    query: {
        /**
         * The page of elements to return, defaults to 1
         */
        page?: number;
        /**
         * The maximum items to return per page, defaults to 20
         */
        limit?: number;
        /**
         * The id of the server to filter journeys on
         */
        serverId: string;
        /**
         * The date of an event (ISO-8601 without timezone), defaults to the current server date if omitted
         */
        date?: string;
        /**
         * The line at an event, at least journeyNumber or line must be provided
         */
        line?: string;
        /**
         * The number at an event, at least journeyNumber or line must be provided
         */
        journeyNumber?: string;
        /**
         * The category at an event
         */
        journeyCategory?: string;
        /**
         * The transport types that are returned, defaults to all types if omitted
         */
        transportTypes?: Array<'NATIONAL_EXPRESS_TRAIN' | 'INTER_NATIONAL_EXPRESS_TRAIN' | 'INTER_REGIONAL_EXPRESS_TRAIN' | 'INTER_REGIONAL_TRAIN' | 'REGIONAL_FAST_TRAIN' | 'REGIONAL_TRAIN' | 'ADDITIONAL_TRAIN' | 'MANEUVER_TRAIN' | 'EMPTY_TRANSFER_TRAIN' | 'INTER_NATIONAL_CARGO_TRAIN' | 'NATIONAL_CARGO_TRAIN' | 'MAINTENANCE_TRAIN'>;
    };
    url: '/sit-journeys/v1/by-event';
};

export type FindJourneysByEventErrors = {
    /**
     * One of the filter parameters is invalid or doesn't match the described grouping requirements
     */
    400: ProblemDetail;
    /**
     * An internal error occurred while processing the request
     */
    500: ProblemDetail;
};

export type FindJourneysByEventError = FindJourneysByEventErrors[keyof FindJourneysByEventErrors];

export type FindJourneysByEventResponses = {
    /**
     * The journeys were successfully resolved based on the given filter parameters
     */
    200: PaginatedResponseDtoJourneySummaryDto;
};

export type FindJourneysByEventResponse = FindJourneysByEventResponses[keyof FindJourneysByEventResponses];

export type ListActiveJourneysData = {
    body?: never;
    headers?: {
        /**
         * If provided the response body is empty in case the data didn't change since the given date
         */
        'If-Modified-Since'?: string;
    };
    path?: never;
    query: {
        /**
         * The id of the server to filter journeys on
         */
        serverId: string;
    };
    url: '/sit-journeys/v1/active';
};

export type ListActiveJourneysErrors = {
    /**
     * One of the filter parameters is invalid
     */
    400: ProblemDetail;
    /**
     * An internal error occurred while processing the request
     */
    500: ProblemDetail;
};

export type ListActiveJourneysError = ListActiveJourneysErrors[keyof ListActiveJourneysErrors];

export type ListActiveJourneysResponses = {
    /**
     * The active journeys of the given server were successfully resolved
     */
    200: Array<JourneyActiveDto>;
};

export type ListActiveJourneysResponse = ListActiveJourneysResponses[keyof ListActiveJourneysResponses];

export type FindDispatchPostsData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * The id of the server on which the dispatch posts should be located
         */
        serverId?: string;
        /**
         * The difficulty of the dispatch posts to return (1-5)
         */
        difficulty?: number;
        /**
         * The id of the point with which the dispatch post is associated
         */
        pointId?: string;
        /**
         * If the post should be deleted (removed from the SimRail backend)
         */
        deleted?: boolean;
        /**
         * The page of elements to return, defaults to 1
         */
        page?: number;
        /**
         * The maximum items to return per page, defaults to 20
         */
        limit?: number;
    };
    url: '/sit-dispatch-posts/v1/find';
};

export type FindDispatchPostsErrors = {
    /**
     * One or multiple of the given filter parameters were invalid
     */
    400: ProblemDetail;
    /**
     * An internal error occurred while processing the request
     */
    500: ProblemDetail;
};

export type FindDispatchPostsError = FindDispatchPostsErrors[keyof FindDispatchPostsErrors];

export type FindDispatchPostsResponses = {
    /**
     * The dispatch posts were successfully resolved based on the given filter parameters
     */
    200: PaginatedResponseDtoDispatchPostInfoDto;
};

export type FindDispatchPostsResponse = FindDispatchPostsResponses[keyof FindDispatchPostsResponses];

export type FindDispatchPostByIdData = {
    body?: never;
    headers?: {
        /**
         * If provided the response body is empty in case the data didn't change since the given date
         */
        'If-Modified-Since'?: string;
    };
    path: {
        /**
         * The id of the dispatch post to get
         */
        id: string;
    };
    query?: never;
    url: '/sit-dispatch-posts/v1/by-id/{id}';
};

export type FindDispatchPostByIdErrors = {
    /**
     * The given dispatch post id is invalid
     */
    400: ProblemDetail;
    /**
     * No dispatch post with the given id exists
     */
    404: unknown;
    /**
     * An internal error occurred while processing the request
     */
    500: ProblemDetail;
};

export type FindDispatchPostByIdError = FindDispatchPostByIdErrors[keyof FindDispatchPostByIdErrors];

export type FindDispatchPostByIdResponses = {
    /**
     * The dispatch post was successfully resolved based on the given id
     */
    200: DispatchPostInfoDto;
};

export type FindDispatchPostByIdResponse = FindDispatchPostByIdResponses[keyof FindDispatchPostByIdResponses];

export type ListBoardDeparturesData = {
    body?: never;
    path?: never;
    query: {
        /**
         * The id of the server to get the board on
         */
        serverId: string;
        /**
         * The id of the point to get the board of
         */
        pointId: string;
        /**
         * The start time for the board, if omitted current server time will be used
         */
        timeStart?: string;
        /**
         * The end time for the board, if omitted the start time plus 30 minutes will be used
         */
        timeEnd?: string;
        /**
         * Filter for transports that should be returned, if omitted all transports will be returned
         */
        transportTypes?: Array<'NATIONAL_EXPRESS_TRAIN' | 'INTER_NATIONAL_EXPRESS_TRAIN' | 'INTER_REGIONAL_EXPRESS_TRAIN' | 'INTER_REGIONAL_TRAIN' | 'REGIONAL_FAST_TRAIN' | 'REGIONAL_TRAIN' | 'ADDITIONAL_TRAIN' | 'MANEUVER_TRAIN' | 'EMPTY_TRANSFER_TRAIN' | 'INTER_NATIONAL_CARGO_TRAIN' | 'NATIONAL_CARGO_TRAIN' | 'MAINTENANCE_TRAIN'>;
        /**
         * Sort order of board entries, of omitted entries will be sorted by realtime time information
         */
        sortBy?: 'REALTIME_TIME' | 'SCHEDULED_TIME';
    };
    url: '/sit-boards/v1/departures';
};

export type ListBoardDeparturesErrors = {
    /**
     * One of the given filter parameters is invalid or doesn't comply to the described constraints
     */
    400: ProblemDetail;
    /**
     * An internal error occurred while processing the request
     */
    500: ProblemDetail;
};

export type ListBoardDeparturesError = ListBoardDeparturesErrors[keyof ListBoardDeparturesErrors];

export type ListBoardDeparturesResponses = {
    /**
     * The departure board entries were successfully resolved
     */
    200: Array<BoardEntryDto>;
};

export type ListBoardDeparturesResponse = ListBoardDeparturesResponses[keyof ListBoardDeparturesResponses];

export type ListBoardArrivalsData = {
    body?: never;
    path?: never;
    query: {
        /**
         * The id of the server to get the board on
         */
        serverId: string;
        /**
         * The id of the point to get the board of
         */
        pointId: string;
        /**
         * The start time for the board, if omitted current server time will be used
         */
        timeStart?: string;
        /**
         * The end time for the board, if omitted the start time plus 30 minutes will be used
         */
        timeEnd?: string;
        /**
         * Filter for transports that should be returned, if omitted all transports will be returned
         */
        transportTypes?: Array<'NATIONAL_EXPRESS_TRAIN' | 'INTER_NATIONAL_EXPRESS_TRAIN' | 'INTER_REGIONAL_EXPRESS_TRAIN' | 'INTER_REGIONAL_TRAIN' | 'REGIONAL_FAST_TRAIN' | 'REGIONAL_TRAIN' | 'ADDITIONAL_TRAIN' | 'MANEUVER_TRAIN' | 'EMPTY_TRANSFER_TRAIN' | 'INTER_NATIONAL_CARGO_TRAIN' | 'NATIONAL_CARGO_TRAIN' | 'MAINTENANCE_TRAIN'>;
        /**
         * Sort order of board entries, of omitted entries will be sorted by realtime time information
         */
        sortBy?: 'REALTIME_TIME' | 'SCHEDULED_TIME';
    };
    url: '/sit-boards/v1/arrivals';
};

export type ListBoardArrivalsErrors = {
    /**
     * One of the given filter parameters is invalid or doesn't comply to the described constraints
     */
    400: ProblemDetail;
    /**
     * An internal error occurred while processing the request
     */
    500: ProblemDetail;
};

export type ListBoardArrivalsError = ListBoardArrivalsErrors[keyof ListBoardArrivalsErrors];

export type ListBoardArrivalsResponses = {
    /**
     * The arrival board entries were successfully resolved
     */
    200: Array<BoardEntryDto>;
};

export type ListBoardArrivalsResponse = ListBoardArrivalsResponses[keyof ListBoardArrivalsResponses];

export type ClientOptions = {
    baseUrl: 'https://apis.simrail.tools' | (string & {});
};